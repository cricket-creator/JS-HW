if (!("a" in window)) { // обращение к глобальному окружению;
    var a = 1; // условие выдаст true, т.к. переменная 'a' объявлена глобально через var;
}
alert(a);   /* в результате того, что условие инвертируется на false, 
            условие не выполнится, но т.к. 'a' объявлено, но значение ей не присвоено,
            то она выдаст undefined; */

var b = function a(x) {
    x && a(--x);
};
alert(a); // тоже undefined, т.к. переменная 'a' так и не присвоено никакое значение
/* если вызвать через переменную alert(b()), которой присвоена эта функция, то будет тоже undefined. */

/* как вы объясняли ранее, функции, записанные таким образом инициализируются перед запуском кода */
function a(x) {
    return x * 2;
}
var a; // переменная 'a' уже объявлена как глобальный объект и изменяться не будет;
alert(a); // при каждом глобальном alert(a), будет вызываться тело функции а;

function b(x, y, a) {
    arguments[2] = 10; // обращение к третьему параметру
    alert(a); // => 10.
}
b(1, 2, 3); // параметры функции выглядят как массив [1, 2, 3] => при выполнении функции [1, 2, 10];

function a() {
    alert(this);
}
a.call(null); // a.call обращается к методу внутри функции 'а', которая вызывает тип функции 'a';